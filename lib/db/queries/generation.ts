import { and, desc, eq, or, sql } from 'drizzle-orm';
import { db } from '../drizzle';
import { generationJob, adImage, JobStatus } from '../schema/index';
import { appendTokenLedgerEntry } from './tokens';
import { getBrandsByUserId } from './brand';

// Generation job operations
export async function createGenerationJob(
  userId: string,
  jobData: {
    id: string;
    prompt?: string; // Now optional
    params: any;
    tokensCost: number;
    brandId?: string; // Optional (can be null for some jobs)
    productPhotoUrls?: string[]; // Array of product photo URLs
    productPhotoMode?: 'brand' | 'custom' | 'mixed'; // Photo mode
    archetypeCode?: string; // FK to ad_archetype
    archetypeMode?: 'single' | 'random'; // 'single' or 'random'
    formats?: string[]; // Array of formats
    selectedInsights?: string[]; // Array of selected insights
    insightSource?: 'auto' | 'manual' | 'mixed'; // Insight source
    promotionValueInsight?: any; // Promotion value configuration
    archetypeInputs?: any; // JSON object
    autoGenerated?: boolean; // True if automatically generated for quick ads
    status?: JobStatus; // Job status
  }
) {
  return await db.transaction(async (tx) => {
    // Skip token deduction for auto-generated jobs (tokens taken when displayed)
    let ledgerEntry = null;
    if (!jobData.autoGenerated) {
      // Deduct tokens for regular generation jobs
      ledgerEntry = await appendTokenLedgerEntry(
        userId,
        -jobData.tokensCost,
        'GENERATION',
        jobData.id
      );
    }

    // Create generation job
    const job = await tx
      .insert(generationJob)
      .values({
        id: jobData.id,
        prompt: jobData.prompt || null,
        params: jobData.params,
        tokensCost: jobData.autoGenerated ? 0 : jobData.tokensCost, // Set to 0 for auto-generated
        userId,
        brandId: jobData.brandId || null,
        productPhotoUrls: jobData.productPhotoUrls || [],
        productPhotoMode: jobData.productPhotoMode || 'brand',
        archetypeCode: jobData.archetypeCode || null,
        archetypeMode: jobData.archetypeMode || 'single',
        formats: jobData.formats || [],
        selectedInsights: jobData.selectedInsights || [],
        insightSource: jobData.insightSource || 'auto',
        promotionValueInsight: jobData.promotionValueInsight || {},
        archetypeInputs: jobData.archetypeInputs || {},
        autoGenerated: jobData.autoGenerated || false,
        ledgerId: ledgerEntry?.id || null,
        status: jobData.status || JobStatus.QUEUED,
      })
      .returning();

    return job[0];
  });
}

/** Find any job (any status) for user with this website URL - most recent first */
export async function getExistingGenerationJobByWebsiteUrl(
  userId: string,
  websiteUrl: string,
  normalizeUrl: (url: string) => string
) {
  const normalizedUrl = normalizeUrl(websiteUrl);
  const userBrands = await getBrandsByUserId(userId);
  const matchingBrand = userBrands.find(
    (b) => normalizeUrl(b.websiteUrl) === normalizedUrl
  );
  const brandId = matchingBrand?.id;

  const result = await db
    .select()
    .from(generationJob)
    .where(
      and(
        eq(generationJob.userId, userId),
        or(
          sql`(${generationJob.params}->>'website_url')::text = ${normalizedUrl}`,
          brandId ? eq(generationJob.brandId, brandId) : sql`1 = 0`
        )!
      )
    )
    .orderBy(desc(generationJob.createdAt))
    .limit(1);

  return result[0] ?? null;
}

export async function getGenerationJobById(jobId: string) {
  const result = await db
    .select()
    .from(generationJob)
    .where(eq(generationJob.id, jobId))
    .limit(1);
  return result[0] || null;
}

export async function getGenerationJobsForUser(userId: string, limit = 20) {
  return await db
    .select({
      job: generationJob,
      adImageCount: sql<number>`count(${adImage.id})::int`,
    })
    .from(generationJob)
    .leftJoin(adImage, eq(generationJob.id, adImage.jobId))
    .where(
      and(
        eq(generationJob.userId, userId),
        // For auto-generated quick ads, only include if they have at least one ready ad image
        or(
          eq(generationJob.autoGenerated, false),
          sql`EXISTS (
            SELECT 1 FROM ${adImage}
            WHERE ${adImage.jobId} = ${generationJob.id}
            AND ${adImage.readyToDisplay} = true
          )`
        )
      )
    )
    .groupBy(generationJob.id)
    .orderBy(desc(generationJob.createdAt))
    .limit(limit);
}

export async function updateGenerationJob(
  jobId: string,
  updates: {
    productPhotoUrls?: string[];
    productPhotoMode?: 'brand' | 'custom' | 'mixed';
    archetypeCode?: string | null;
    archetypeMode?: 'single' | 'random';
    formats?: string[];
    selectedInsights?: string[];
    insightSource?: 'auto' | 'manual' | 'mixed';
    promotionValueInsight?: any;
    archetypeInputs?: any;
    tokensCost?: number;
    ledgerId?: number;
  }
) {
  const [updated] = await db
    .update(generationJob)
    .set(updates)
    .where(eq(generationJob.id, jobId))
    .returning();

  return updated;
}

export async function updateGenerationJobStatus(
  jobId: string,
  status: 'QUEUED' | 'RUNNING' | 'SUCCEEDED' | 'FAILED' | 'CANCELED',
  errorCode?: string,
  errorMessage?: string
) {
  const updates: any = {
    status,
    completedAt: new Date(),
  };

  if (status === 'RUNNING') {
    updates.startedAt = new Date();
    delete updates.completedAt;
  }

  if (errorCode) updates.errorCode = errorCode;
  if (errorMessage) updates.errorMessage = errorMessage;

  await db
    .update(generationJob)
    .set(updates)
    .where(eq(generationJob.id, jobId));
}

export async function deleteGenerationJob(jobId: string) {
  // Update status to CANCELED (soft delete)
  await updateGenerationJobStatus(jobId, 'CANCELED');
}

export async function hardDeleteGenerationJob(jobId: string) {
  const [deleted] = await db
    .delete(generationJob)
    .where(eq(generationJob.id, jobId))
    .returning({ id: generationJob.id });
  return deleted;
}

export async function markGenerationJobAsViewed(jobId: string) {
  const [updated] = await db
    .update(generationJob)
    .set({ viewedAt: new Date() })
    .where(eq(generationJob.id, jobId))
    .returning();
  return updated;
}