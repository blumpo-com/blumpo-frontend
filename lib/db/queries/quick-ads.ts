import { randomUUID } from 'crypto';
import { createGenerationJob, getGenerationJobById } from './generation';
import { db } from '../drizzle';
import { generationJob, adImage, JobStatus } from '../schema';
import { eq, and, sql, inArray, ne } from 'drizzle-orm';
import { getAdImagesByJobId, markAdImagesAsDeleted } from './ads';
import { del } from '@vercel/blob';
import { extractBlobPathFromUrl } from '@/lib/blob-utils';

/**
 * Creates a new quick ads generation job
 * - Generates 10 ads total (5 per format: 1:1 and 9:16)
 * - Tokens will be deducted when job is created via reserveTokens
 * - Sets autoGenerated flag to true
 */
export async function createQuickAdsJob(
  userId: string,
  brandId: string,
  tokensCost: number = 50,
  formats: string[] = ['1:1', '9:16'],
  autoGenerated: boolean = true,
  status: JobStatus = JobStatus.QUEUED
) {
  const jobId = randomUUID();
  
  const job = await createGenerationJob(userId, {
    id: jobId,
    prompt: undefined, // Will be generated by n8n
    params: {}, // Default params
    tokensCost: 0, // Will be set via reserveTokens in the route
    brandId,
    insightSource: 'auto',
    archetypeInputs: {},
    formats: formats,
    autoGenerated: autoGenerated,
    status: status,
  });


  return job;
}

/**
 * Find or create a quick ads job that needs more ads
 * Returns a job that has less than 5 ads per format (target: 5 ads per format)
 * Once a job has 5+ ads in both formats, create a new job
 */
export async function findOrCreateJobForMigration(
  userId: string,
  brandId: string | null
): Promise<{ id: string; status: string }> {
  // Find existing QUEUED or SUCCEEDED jobs that need more ads
  // Only look for jobs with less than 5 ads in at least one format
  // Prefer QUEUED jobs over SUCCEEDED jobs (SUCCEEDED jobs with 5+ ads in both formats should not be used)
  const existingJobs = await db
    .select({
      job: generationJob,
      format1x1Count: sql<number>`
        COALESCE((
          SELECT COUNT(*)::int 
          FROM ad_image ai
          WHERE ai.job_id = generation_job.id
            AND ai.format = '1:1'
            AND ai.is_deleted = false
            AND ai.ready_to_display = false
        ), 0)
      `.as('format1x1Count'),
      format9x16Count: sql<number>`
        COALESCE((
          SELECT COUNT(*)::int 
          FROM ad_image ai
          WHERE ai.job_id = generation_job.id
            AND ai.format = '9:16'
            AND ai.is_deleted = false
            AND ai.ready_to_display = false
        ), 0)
      `.as('format9x16Count'),
    })
    .from(generationJob)
    .where(
      and(
        eq(generationJob.userId, userId),
        brandId ? eq(generationJob.brandId, brandId) : sql`${generationJob.brandId} IS NULL`,
        eq(generationJob.autoGenerated, true),
        sql`${generationJob.status} IN ('QUEUED', 'SUCCEEDED')`
      )
    )
    .orderBy(
      // Prefer QUEUED jobs first, then by creation date
      sql`CASE WHEN ${generationJob.status} = 'QUEUED' THEN 0 ELSE 1 END`,
      generationJob.createdAt
    );

  // Find a job that needs more ads (less than 5 per format)
  // Once a job has 5+ ads in both formats, create a new job
  // Skip SUCCEEDED jobs that already have 5+ ads in both formats (they're complete)
  for (const row of existingJobs) {
    const { job, format1x1Count, format9x16Count } = row;
    
    // Skip SUCCEEDED jobs that already have 5+ ads in both formats (they're complete)
    if (job.status === 'SUCCEEDED' && format1x1Count >= 5 && format9x16Count >= 5) {
      console.log(`[QUICK-ADS-MIGRATION] Skipping SUCCEEDED job ${job.id} with ${format1x1Count} 1:1 ads and ${format9x16Count} 9:16 ads (already complete)`);
      continue;
    }
    
    // Check if job needs more ads (less than 5 in at least one format)
    if (format1x1Count < 5 || format9x16Count < 5) {
      console.log(`[QUICK-ADS-MIGRATION] Found existing job ${job.id} with ${format1x1Count} 1:1 ads and ${format9x16Count} 9:16 ads`);
      return job;
    }
  }

  // No existing job found, create a new QUEUED job
  console.log('[QUICK-ADS-MIGRATION] No existing job found, creating new QUEUED job');
  
  if (!brandId) {
    // Create job with null brandId manually
    const jobId = randomUUID();
    const newJob = await createGenerationJob(userId, {
      id: jobId,
      prompt: undefined,
      params: {},
      tokensCost: 0,
      brandId: undefined,
      insightSource: 'auto',
      archetypeInputs: {},
      formats: ['1:1', '9:16'],
      autoGenerated: true,
    });
    return newJob;
  }

  // Pass JobStatus.QUEUED as the fifth argument (status) in the correct parameter order
  const newJob = await createQuickAdsJob(
    userId,
    brandId,
    0,              // tokensCost (default 0)
    ['1:1', '9:16'], // formats (default both)
    true,           // autoGenerated
    JobStatus.QUEUED // status
  );
  return newJob;
}
/**
 * Migrate ads from a failed job to an existing or new job
 * - Matches ads by workflowId to ensure format pairs (1:1 and 9:16)
 * - Only migrates enough pairs to reach 5 ads per format in target job (doesn't exceed)
 * - Creates new jobs for remaining pairs if needed
 * - Sets target job status to SUCCEEDED if it reaches 5 ads in each format
 * - Removes orphaned ads (ads without matching format pair)
 * - Returns the number of ads migrated and jobs created
 */
export async function migrateFailedJobAds(
  failedJobId: string,
  targetJobId: string,
  userId: string,
  brandId: string | null
): Promise<{ migrated: number; orphaned: number; newJobsCreated: number }> {
  // Get all ads from the failed job
  const failedJobAds = await getAdImagesByJobId(failedJobId);
  
  // Filter out deleted ads
  const validAds = failedJobAds.filter(ad => !ad.isDeleted);

  if (validAds.length === 0) {
    return { migrated: 0, orphaned: 0, newJobsCreated: 0 };
  }

  // Get current ad counts for target job
  const targetJobAds = await getAdImagesByJobId(targetJobId);
  const targetJobValidAds = targetJobAds.filter(ad => !ad.isDeleted && !ad.readyToDisplay);
  const targetJob1x1Count = targetJobValidAds.filter(ad => ad.format === '1:1').length;
  const targetJob9x16Count = targetJobValidAds.filter(ad => ad.format === '9:16').length;

  console.log(`[QUICK-ADS-MIGRATION] Target job ${targetJobId} has ${targetJob1x1Count} 1:1 ads and ${targetJob9x16Count} 9:16 ads`);

  // Calculate how many pairs we need to reach 5 per format
  const needed1x1 = Math.max(0, 5 - targetJob1x1Count);
  const needed9x16 = Math.max(0, 5 - targetJob9x16Count);
  const pairsNeeded = Math.max(needed1x1, needed9x16);

  console.log(`[QUICK-ADS-MIGRATION] Need ${pairsNeeded} pairs to fill target job (need ${needed1x1} 1:1, ${needed9x16} 9:16)`);

  // Group ads by workflowId
  const adsByWorkflow = new Map<string, typeof validAds>();
  for (const ad of validAds) {
    const workflowId = ad.workflowId || 'no-workflow';
    if (!adsByWorkflow.has(workflowId)) {
      adsByWorkflow.set(workflowId, []);
    }
    adsByWorkflow.get(workflowId)!.push(ad);
  }

  // Find pairs (1:1 and 9:16 with same workflowId)
  const pairs: Array<{ ad1x1: typeof validAds[0]; ad9x16: typeof validAds[0] }> = [];
  const orphanedAds: typeof validAds = [];

  for (const [workflowId, ads] of adsByWorkflow.entries()) {
    const ad1x1 = ads.find(ad => ad.format === '1:1');
    const ad9x16 = ads.find(ad => ad.format === '9:16');

    if (ad1x1 && ad9x16) {
      // We have a pair
      pairs.push({ ad1x1, ad9x16 });
    } else {
      // Orphaned ads (missing format pair)
      if (ad1x1) orphanedAds.push(ad1x1);
      if (ad9x16) orphanedAds.push(ad9x16);
    }
  }

  // Migrate only the pairs needed to fill the target job (up to 5 per format)
  const pairsToMigrate = pairs.slice(0, pairsNeeded);
  const remainingPairs = pairs.slice(pairsNeeded);

  const adsToMigrate: string[] = [];
  for (const pair of pairsToMigrate) {
    adsToMigrate.push(pair.ad1x1.id);
    adsToMigrate.push(pair.ad9x16.id);
  }

  // Update jobId for migrated ads
  if (adsToMigrate.length > 0) {
    await db
      .update(adImage)
      .set({ jobId: targetJobId })
      .where(inArray(adImage.id, adsToMigrate));
    
    console.log(`[QUICK-ADS-MIGRATION] Migrated ${pairsToMigrate.length} pairs (${adsToMigrate.length} ads) to target job ${targetJobId}`);
  }

  // Check if target job now has 5 ads in each format and update status to SUCCEEDED
  const updatedTargetJobAds = await getAdImagesByJobId(targetJobId);
  const updatedTargetJobValidAds = updatedTargetJobAds.filter(ad => !ad.isDeleted && !ad.readyToDisplay);
  const updatedTargetJob1x1Count = updatedTargetJobValidAds.filter(ad => ad.format === '1:1').length;
  const updatedTargetJob9x16Count = updatedTargetJobValidAds.filter(ad => ad.format === '9:16').length;

  if (updatedTargetJob1x1Count >= 5 && updatedTargetJob9x16Count >= 5) {
    const targetJob = await getGenerationJobById(targetJobId);
    if (targetJob && targetJob.status !== 'SUCCEEDED') {
      await db
        .update(generationJob)
        .set({
          status: 'SUCCEEDED',
          completedAt: new Date(),
        })
        .where(eq(generationJob.id, targetJobId));
      console.log(`[QUICK-ADS-MIGRATION] Target job ${targetJobId} now has 5+ ads in both formats, setting status to SUCCEEDED`);
    }
  }

  // Create new jobs for remaining pairs
  let newJobsCreated = 0;
  let currentNewJob: { id: string; status: string } | null = null;
  let currentNewJobAds: typeof validAds = [];

  for (const pair of remainingPairs) {
    // Check if we need a new job or can use the current one
    if (!currentNewJob || currentNewJobAds.length >= 10) {
      // Create a new job
      currentNewJob = await findOrCreateJobForMigration(userId, brandId);
      currentNewJobAds = [];
      newJobsCreated++;
      console.log(`[QUICK-ADS-MIGRATION] Created/found new job ${currentNewJob.id} for remaining pairs`);
    }

    // Migrate pair to current new job
    await db
      .update(adImage)
      .set({ jobId: currentNewJob.id })
      .where(inArray(adImage.id, [pair.ad1x1.id, pair.ad9x16.id]));
    
    currentNewJobAds.push(pair.ad1x1, pair.ad9x16);

    // Check if this new job now has 5 ads in each format
    const newJobAds = await getAdImagesByJobId(currentNewJob.id);
    const newJobValidAds = newJobAds.filter(ad => !ad.isDeleted && !ad.readyToDisplay);
    const newJob1x1Count = newJobValidAds.filter(ad => ad.format === '1:1').length;
    const newJob9x16Count = newJobValidAds.filter(ad => ad.format === '9:16').length;

    if (newJob1x1Count >= 5 && newJob9x16Count >= 5) {
      const newJob = await getGenerationJobById(currentNewJob.id);
      if (newJob && newJob.status !== 'SUCCEEDED') {
        await db
          .update(generationJob)
          .set({
            status: 'SUCCEEDED',
            completedAt: new Date(),
          })
          .where(eq(generationJob.id, currentNewJob.id));
        console.log(`[QUICK-ADS-MIGRATION] New job ${currentNewJob.id} now has 5+ ads in both formats, setting status to SUCCEEDED`);
        // Reset to create a new job for next pairs
        currentNewJob = null;
        currentNewJobAds = [];
      }
    }
  }

  // Delete orphaned ads from Vercel Blob and mark as deleted in DB
  const orphanedIds: string[] = [];
  for (const orphanedAd of orphanedAds) {
    try {
      // Delete from Vercel Blob
      let blobPath: string | null = null;
      
      if (orphanedAd.publicUrl) {
        blobPath = extractBlobPathFromUrl(orphanedAd.publicUrl);
      }
      
      if (!blobPath && orphanedAd.storageKey) {
        blobPath = orphanedAd.storageKey;
      }
      
      if (blobPath) {
        await del(blobPath);
      }
    } catch (error) {
      console.error(`[QUICK-ADS-MIGRATION] Error deleting blob for orphaned ad ${orphanedAd.id}:`, error);
    }
    
    orphanedIds.push(orphanedAd.id);
  }

  // Mark orphaned ads as deleted
  if (orphanedIds.length > 0) {
    await markAdImagesAsDeleted(orphanedIds);
  }

  return {
    migrated: adsToMigrate.length,
    orphaned: orphanedIds.length,
    newJobsCreated,
  };
}

/**
 * Clean up a failed generation job after migration
 * Marks the job as CANCELED and removes it from active processing
 */
export async function cleanupFailedJob(jobId: string): Promise<void> {
  await db
    .update(generationJob)
    .set({
      status: 'CANCELED',
      completedAt: new Date(),
    })
    .where(eq(generationJob.id, jobId));
}

/**
 * Delete ad images from database (hard delete)
 * This is used when we want to completely remove ads, not just mark them as deleted
 */
export async function deleteAdImages(adImageIds: string[]): Promise<void> {
  if (adImageIds.length === 0) return;
  
  await db
    .delete(adImage)
    .where(inArray(adImage.id, adImageIds));
}
