import { randomUUID } from 'crypto';
import { createGenerationJob, getGenerationJobById } from './generation';
import { db } from '../drizzle';
import { generationJob, adImage } from '../schema';
import { eq, and, sql, inArray, ne } from 'drizzle-orm';
import { getAdImagesByJobId, markAdImagesAsDeleted } from './ads';
import { del } from '@vercel/blob';
import { extractBlobPathFromUrl } from '@/lib/blob-utils';

/**
 * Creates a new quick ads generation job
 * - Generates 10 ads total (5 per format: 1:1 and 9:16)
 * - Tokens will be deducted when job is created via reserveTokens
 * - Sets autoGenerated flag to true
 */
export async function createQuickAdsJob(
  userId: string,
  brandId: string,
  tokensCost: number = 50
) {
  const jobId = randomUUID();
  
  const job = await createGenerationJob(userId, {
    id: jobId,
    prompt: undefined, // Will be generated by n8n
    params: {}, // Default params
    tokensCost: 0, // Will be set via reserveTokens in the route
    brandId,
    insightSource: 'auto',
    archetypeInputs: {},
    formats: ['1:1', '9:16'], // Always generate both formats for quick ads
    autoGenerated: true,
  });

  return job;
}

/**
 * Find or create a quick ads job that needs more ads
 * Returns a job that has less than 10 ads per format (up to 20 total)
 */
export async function findOrCreateJobForMigration(
  userId: string,
  brandId: string | null
): Promise<{ id: string; status: string }> {
  // Find existing QUEUED or SUCCEEDED jobs that need more ads
  const existingJobs = await db
    .select({
      job: generationJob,
      format1x1Count: sql<number>`
        COALESCE((
          SELECT COUNT(*)::int FROM ${adImage} 
          WHERE ${adImage.jobId} = ${generationJob.id} 
          AND ${adImage.format} = '1:1' 
          AND ${adImage.isDeleted} = false
          AND ${adImage.readyToDisplay} = false
        ), 0)
      `,
      format9x16Count: sql<number>`
        COALESCE((
          SELECT COUNT(*)::int FROM ${adImage} 
          WHERE ${adImage.jobId} = ${generationJob.id} 
          AND ${adImage.format} = '9:16' 
          AND ${adImage.isDeleted} = false
          AND ${adImage.readyToDisplay} = false
        ), 0)
      `,
    })
    .from(generationJob)
    .where(
      and(
        eq(generationJob.userId, userId),
        brandId ? eq(generationJob.brandId, brandId) : sql`${generationJob.brandId} IS NULL`,
        eq(generationJob.autoGenerated, true),
        sql`${generationJob.status} IN ('QUEUED', 'SUCCEEDED')`
      )
    )
    .orderBy(generationJob.createdAt);

  // Find a job that needs more ads (less than 10 per format)
  for (const row of existingJobs) {
    const { job, format1x1Count, format9x16Count } = row;
    // Check if job needs more ads (less than 10 in either format)
    if (format1x1Count < 10 || format9x16Count < 10) {
      console.log(`[QUICK-ADS-MIGRATION] Found existing job ${job.id} with ${format1x1Count} 1:1 ads and ${format9x16Count} 9:16 ads`);
      return job;
    }
  }

  // No existing job found, create a new QUEUED job
  console.log('[QUICK-ADS-MIGRATION] No existing job found, creating new QUEUED job');
  
  if (!brandId) {
    // Create job with null brandId manually
    const jobId = randomUUID();
    const newJob = await createGenerationJob(userId, {
      id: jobId,
      prompt: undefined,
      params: {},
      tokensCost: 0,
      brandId: undefined,
      insightSource: 'auto',
      archetypeInputs: {},
      formats: ['1:1', '9:16'],
      autoGenerated: true,
    });
    return newJob;
  }
  
  const newJob = await createQuickAdsJob(userId, brandId);
  return newJob;
}

/**
 * Migrate ads from a failed job to an existing or new job
 * - Matches ads by workflowId to ensure format pairs (1:1 and 9:16)
 * - Removes orphaned ads (ads without matching format pair)
 * - Updates ads to point to the target job
 * - Returns the number of ads migrated
 */
export async function migrateFailedJobAds(
  failedJobId: string,
  targetJobId: string
): Promise<{ migrated: number; orphaned: number }> {
  // Get all ads from the failed job
  const failedJobAds = await getAdImagesByJobId(failedJobId);
  
  // Filter out deleted ads
  const validAds = failedJobAds.filter(ad => !ad.isDeleted);

  if (validAds.length === 0) {
    return { migrated: 0, orphaned: 0 };
  }

  // Group ads by workflowId
  const adsByWorkflow = new Map<string, typeof validAds>();
  for (const ad of validAds) {
    const workflowId = ad.workflowId || 'no-workflow';
    if (!adsByWorkflow.has(workflowId)) {
      adsByWorkflow.set(workflowId, []);
    }
    adsByWorkflow.get(workflowId)!.push(ad);
  }

  // Find pairs (1:1 and 9:16 with same workflowId)
  const pairs: Array<{ ad1x1: typeof validAds[0]; ad9x16: typeof validAds[0] }> = [];
  const orphanedAds: typeof validAds = [];

  for (const [workflowId, ads] of adsByWorkflow.entries()) {
    const ad1x1 = ads.find(ad => ad.format === '1:1');
    const ad9x16 = ads.find(ad => ad.format === '9:16');

    if (ad1x1 && ad9x16) {
      // We have a pair
      pairs.push({ ad1x1, ad9x16 });
    } else {
      // Orphaned ads (missing format pair)
      if (ad1x1) orphanedAds.push(ad1x1);
      if (ad9x16) orphanedAds.push(ad9x16);
    }
  }

  // Migrate pairs to target job
  const adsToMigrate: string[] = [];
  for (const pair of pairs) {
    adsToMigrate.push(pair.ad1x1.id);
    adsToMigrate.push(pair.ad9x16.id);
  }

  // Update jobId for migrated ads
  if (adsToMigrate.length > 0) {
    await db
      .update(adImage)
      .set({ jobId: targetJobId })
      .where(inArray(adImage.id, adsToMigrate));
  }

  // Delete orphaned ads from Vercel Blob and mark as deleted in DB
  const orphanedIds: string[] = [];
  for (const orphanedAd of orphanedAds) {
    try {
      // Delete from Vercel Blob
      let blobPath: string | null = null;
      
      if (orphanedAd.publicUrl) {
        blobPath = extractBlobPathFromUrl(orphanedAd.publicUrl);
      }
      
      if (!blobPath && orphanedAd.storageKey) {
        blobPath = orphanedAd.storageKey;
      }
      
      if (blobPath) {
        await del(blobPath);
      }
    } catch (error) {
      console.error(`[QUICK-ADS-MIGRATION] Error deleting blob for orphaned ad ${orphanedAd.id}:`, error);
    }
    
    orphanedIds.push(orphanedAd.id);
  }

  // Mark orphaned ads as deleted
  if (orphanedIds.length > 0) {
    await markAdImagesAsDeleted(orphanedIds);
  }

  return {
    migrated: adsToMigrate.length,
    orphaned: orphanedIds.length,
  };
}

/**
 * Clean up a failed generation job after migration
 * Marks the job as CANCELED and removes it from active processing
 */
export async function cleanupFailedJob(jobId: string): Promise<void> {
  await db
    .update(generationJob)
    .set({
      status: 'CANCELED',
      completedAt: new Date(),
    })
    .where(eq(generationJob.id, jobId));
}
