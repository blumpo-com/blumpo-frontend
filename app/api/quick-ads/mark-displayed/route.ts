import { NextResponse } from "next/server";
import { getUser, hasEnoughTokens, appendTokenLedgerEntry } from "@/lib/db/queries";
import { markAdsAsReadyToDisplay, getUnusedFormatAds } from "@/lib/db/queries/ads";
import { getAdImagesByJobId } from "@/lib/db/queries/ads";
import { del } from "@vercel/blob";
import { extractBlobPathFromUrl } from "@/lib/blob-utils";
import { deleteAdImages } from "@/lib/db/queries/quick-ads";
import { getGenerationJobById, updateGenerationJob } from "@/lib/db/queries/generation";

const TOKENS_COST_PER_GENERATION = 50;

// Mark ads as displayed, deduct tokens, and cleanup unused formats
// Supports single format ('1:1' or '9:16') or mixed format ('mixed', '1:1,9:16', '1:1-9:16')
export async function POST(req: Request) {
  try {
    const user = await getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const { jobId, format } = body; // format: '1:1', '9:16', 'mixed', '1:1,9:16', or '1:1-9:16'

    if (!jobId || !format) {
      return NextResponse.json({ error: "jobId and format required" }, { status: 400 });
    }

    // Get generation job to check if it's auto-generated and if tokens were already deducted
    const job = await getGenerationJobById(jobId);
    if (!job) {
      return NextResponse.json({ error: "Generation job not found" }, { status: 404 });
    }

    // Verify job belongs to user
    if (job.userId !== user.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
    }

    // Verify this is a quick ads job
    if (!job.autoGenerated) {
      return NextResponse.json({ error: "Not a quick ads job" }, { status: 400 });
    }

    // Get all ads from this job
    const allAds = await getAdImagesByJobId(jobId);
    
    // Check if format is mixed (both formats)
    const isMixedFormat = format === 'mixed' || format === '1:1,9:16' || format === '1:1-9:16';
    
    let selectedFormatAds: typeof allAds;
    let unusedAds: typeof allAds = [];
    
    if (isMixedFormat) {
      // For mixed format, mark all ads as displayed (both formats)
      selectedFormatAds = allAds.filter(ad => !ad.isDeleted);
      
      // Don't delete anything for mixed format - keep both formats
      unusedAds = [];
    } else {
      // For single format, filter ads in the selected format
      selectedFormatAds = allAds.filter(ad => ad.format === format && !ad.isDeleted);
      
      // Get unused format ads (ads not in selected format)
      unusedAds = await getUnusedFormatAds(jobId, format as '1:1' | '9:16');
    }
    
    if (selectedFormatAds.length === 0) {
      return NextResponse.json({ error: "No ads found for selected format" }, { status: 404 });
    }

    // Deduct tokens when ads are displayed (only if not already deducted)
    if (job.tokensCost === 0 || !job.ledgerId) {
      // Check if user has enough tokens
      const hasTokens = await hasEnoughTokens(user.id, TOKENS_COST_PER_GENERATION);
      if (!hasTokens) {
        return NextResponse.json({
          error: "Insufficient tokens",
          error_code: "INSUFFICIENT_TOKENS",
          tokens_required: TOKENS_COST_PER_GENERATION
        }, { status: 402 });
      }

      // Deduct tokens and update job
      const ledgerEntry = await appendTokenLedgerEntry(
        user.id,
        -TOKENS_COST_PER_GENERATION,
        'GENERATION',
        jobId
      );

      await updateGenerationJob(jobId, {
        tokensCost: TOKENS_COST_PER_GENERATION,
        ledgerId: ledgerEntry.id,
      });

      console.log('[QUICK-ADS] Tokens deducted when ads displayed:', TOKENS_COST_PER_GENERATION);
    }

    // Mark selected format ads as ready to display
    const adIds = selectedFormatAds.map(ad => ad.id);
    await markAdsAsReadyToDisplay(adIds);

    // Only delete unused format ads if NOT mixed format
    if (!isMixedFormat && unusedAds.length > 0) {
      // Delete unused ads from Vercel Blob
      const deletePromises = unusedAds.map(async (ad) => {
        try {
          let blobPath: string | null = null;
          
          // Try to extract blob path from publicUrl first
          if (ad.publicUrl) {
            blobPath = extractBlobPathFromUrl(ad.publicUrl);
          }
          
          // Fallback to storageKey if publicUrl extraction failed
          if (!blobPath && ad.storageKey) {
            blobPath = ad.storageKey;
          }
          
          // Delete from Vercel Blob if we have a valid path
          if (blobPath) {
            await del(blobPath);
            console.log(`[QUICK-ADS] Deleted blob for ad ${ad.id}`);
          } else {
            console.warn(`[QUICK-ADS] No blob path found for ad ${ad.id} (publicUrl: ${ad.publicUrl}, storageKey: ${ad.storageKey})`);
          }
        } catch (error) {
          console.error(`[QUICK-ADS] Error deleting blob for ad ${ad.id}:`, error);
        }
      });

      await Promise.all(deletePromises);
      
      // Delete unused ads from database (hard delete)
      const unusedAdIds = unusedAds.map(ad => ad.id);
      if (unusedAdIds.length > 0) {
        await deleteAdImages(unusedAdIds);
        console.log(`[QUICK-ADS] Deleted ${unusedAdIds.length} unused ads from database`);
      }
    }

    return NextResponse.json({
      success: true,
      markedAsDisplayed: adIds.length,
      deleted: isMixedFormat ? 0 : unusedAds.length,
      isMixedFormat,
    });
  } catch (error) {
    console.error('[QUICK-ADS] Error marking ads as displayed:', error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

