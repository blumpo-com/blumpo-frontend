'use client';

import { Suspense, useState, useEffect, useRef } from 'react';
import { useSearchParams } from 'next/navigation';
import { TinderView, AdFormat } from '../tinder-view';
import { TinderViewMixed } from '../tinder-view-mixed';
import styles from '../tinder-view.module.css';

// Use NEXT_PUBLIC_ prefix for client-side access
const IS_TEST_MODE = process.env.NEXT_PUBLIC_IS_TEST_MODE === 'true';

// Test ads data
const testAds1_1 = [
  { id: '1', imageUrl: '/images/default_ads/tinder/tinder_test_1-1_1.png', format: '1:1' as const },
  { id: '2', imageUrl: '/images/default_ads/tinder/tinder_test_1-1_2.png', format: '1:1' as const },
  { id: '3', imageUrl: '/images/default_ads/tinder/tinder_test_1-1_3.png', format: '1:1' as const },
  { id: '4', imageUrl: '/images/default_ads/tinder/tinder_test_1-1_2.png', format: '1:1' as const },
  { id: '5', imageUrl: '/images/default_ads/tinder/tinder_test_1-1_3.png', format: '1:1' as const },
];

const testAds16_9 = [
  { id: '1', imageUrl: '/images/default_ads/tinder/tinder_test_16-9_1.png', format: '9:16' as const },
  { id: '2', imageUrl: '/images/default_ads/tinder/tinder_test_16-9_2.png', format: '9:16' as const },
  { id: '3', imageUrl: '/images/default_ads/tinder/tinder_test_16-9_3.png', format: '9:16' as const },
  { id: '4', imageUrl: '/images/default_ads/tinder/tinder_test_16-9_2.png', format: '9:16' as const },
  { id: '5', imageUrl: '/images/default_ads/tinder/tinder_test_16-9_3.png', format: '9:16' as const },
];

const testAdsMixed = [
  ...testAds1_1,
  ...testAds16_9,
];

function TinderPageContent() {
  const searchParams = useSearchParams();
  const jobId = searchParams.get('job_id');
  const formatParam = searchParams.get('format') || '1:1';
  const isTest = searchParams.get('test') === 'true';
  
  const [ads1_1, setAds1_1] = useState<Array<{ id: string; imageUrl: string; format: '1:1'; workflowId: string }>>(
    testAds1_1.map(ad => ({ ...ad, workflowId: 'test-workflow' }))
  );
  const [ads16_9, setAds16_9] = useState<Array<{ id: string; imageUrl: string; format: '9:16'; workflowId: string }>>(
    testAds16_9.map(ad => ({ ...ad, workflowId: 'test-workflow' }))
  );
  const [loading, setLoading] = useState(!isTest && !!jobId);
  const [isCompleting, setIsCompleting] = useState(false);
  const [savedIds, setSavedIds] = useState<Set<string>>(new Set());
  const [deletedIds, setDeletedIds] = useState<Set<string>>(new Set());
  const [downloadedIds, setDownloadedIds] = useState<Set<string>>(new Set());
  const [hasCompleted, setHasCompleted] = useState(false);
  const [isFinished, setIsFinished] = useState(false);
  // Ref to prevent double execution (React Strict Mode)
  const hasMarkedAsDisplayedRef = useRef<string | null>(null);
  
  // Convert format parameter to AdFormat type
  // Handle '1:1,9:16' or '1:1-9:16' as mixed format
  const format: AdFormat = 
    formatParam === 'mixed' || formatParam === '1:1,9:16' || formatParam === '1:1-9:16'
      ? 'mixed'
      : formatParam === '9:16'
      ? '9:16'
      : '1:1';

  // Mark ads as displayed when page loads (for quick ads only)
  // Check if this is a quick ads job by checking URL params or job status
  useEffect(() => {
    // Create a unique key for this job+format combination
    const executionKey = `${jobId}-${formatParam}`;
    
    // Don't run if we've already marked this job+format as displayed
    if (!isTest && jobId && formatParam && hasMarkedAsDisplayedRef.current !== executionKey) {
      // Mark as initiated to prevent double execution
      hasMarkedAsDisplayedRef.current = executionKey;
      
      const markAdsAsDisplayed = async () => {
        try {
          // First, check if this is a quick ads job by fetching job info
          const jobResponse = await fetch(`/api/generation-job?jobId=${jobId}`);
          if (!jobResponse.ok) {
            console.warn('[AD-REVIEW] Could not fetch job info, skipping mark-displayed');
            // Reset ref on error so it can retry if needed
            if (hasMarkedAsDisplayedRef.current === executionKey) {
              hasMarkedAsDisplayedRef.current = null;
            }
            return;
          }
          
          const job = await jobResponse.json();
          
          // Only mark as displayed for quick ads jobs (autoGenerated)
          if (!job.autoGenerated) {
            console.log('[AD-REVIEW] Not a quick ads job, skipping mark-displayed');
            return;
          }
          
          // Call mark-displayed API to mark ads as displayed and deduct tokens
          const response = await fetch('/api/quick-ads/mark-displayed', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              jobId, 
              format: formatParam === 'mixed' || formatParam === '1:1,9:16' || formatParam === '1:1-9:16' 
                ? 'mixed' 
                : formatParam 
            }),
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log('[AD-REVIEW] Ads marked as displayed:', result);
          } else {
            const error = await response.json().catch(() => ({}));
            // Don't block the UI if marking fails - just log it
            console.warn('[AD-REVIEW] Failed to mark ads as displayed:', error);
            // Reset ref on error so it can retry if needed
            if (hasMarkedAsDisplayedRef.current === executionKey) {
              hasMarkedAsDisplayedRef.current = null;
            }
          }
        } catch (error) {
          console.error('[AD-REVIEW] Error marking ads as displayed:', error);
          // Reset ref on error so it can retry if needed
          if (hasMarkedAsDisplayedRef.current === executionKey) {
            hasMarkedAsDisplayedRef.current = null;
          }
        }
      };
      
      markAdsAsDisplayed();
    }
  }, [jobId, formatParam, isTest]);

  // Fetch real ads if not in test mode
  useEffect(() => {
    if (!isTest && jobId) {
      const fetchAds = async () => {
        try {
          setLoading(true);
          const response = await fetch(`/api/ad-images?jobId=${jobId}`);
          if (response.ok) {
            const adImages = await response.json();
            
            // Group ads by their provided .format value instead of ratio
            const ads1_1List: Array<{ id: string; imageUrl: string; format: '1:1'; workflowId: string }> = [];
            const ads16_9List: Array<{ id: string; imageUrl: string; format: '9:16'; workflowId: string }> = [];

            adImages.forEach((img: any) => {
              const adData = {
                id: img.id,
                imageUrl: img.publicUrl || img.storageKey,
                workflowId: img.workflowId || 'no-workflow',
              };

              console.log('img', img);

              // Use img.format field directly
              if (img.format === '1:1' || img.format === 'square') {
                ads1_1List.push({ ...adData, format: '1:1' as const });
              } else if (img.format === '9:16' || img.format === 'story') {
                ads16_9List.push({ ...adData, format: '9:16' as const });
              } else {
                // Fallback: push to 1:1 if format is missing/unknown
                ads1_1List.push({ ...adData, format: '1:1' as const });
              }
            });

            console.log('ads1_1List', ads1_1List);
            console.log('ads16_9List', ads16_9List);

            // if mixed format, sort and pair ads by workflowId to ensure matching pairs
            if (format === 'mixed') {
              // Create maps of workflowId to ads for pairing
              const workflowMap1_1 = new Map<string, typeof ads1_1List>();
              const workflowMap16_9 = new Map<string, typeof ads16_9List>();
              
              ads1_1List.forEach(ad => {
                if (!workflowMap1_1.has(ad.workflowId)) {
                  workflowMap1_1.set(ad.workflowId, []);
                }
                workflowMap1_1.get(ad.workflowId)!.push(ad);
              });
              
              ads16_9List.forEach(ad => {
                if (!workflowMap16_9.has(ad.workflowId)) {
                  workflowMap16_9.set(ad.workflowId, []);
                }
                workflowMap16_9.get(ad.workflowId)!.push(ad);
              });
              
              // Get all unique workflowIds and sort them
              const allWorkflowIds = Array.from(new Set([...ads1_1List.map(a => a.workflowId), ...ads16_9List.map(a => a.workflowId)])).sort();
              
              // Rebuild lists ensuring pairs are at the same index
              const final1_1: typeof ads1_1List = [];
              const final16_9: typeof ads16_9List = [];
              
              for (const workflowId of allWorkflowIds) {
                const ads1_1 = workflowMap1_1.get(workflowId) || [];
                const ads16_9 = workflowMap16_9.get(workflowId) || [];
                
                // Pair up ads with the same workflowId
                // Add pairs first (matching indices)
                const minPairs = Math.min(ads1_1.length, ads16_9.length);
                for (let i = 0; i < minPairs; i++) {
                  final1_1.push(ads1_1[i]);
                  final16_9.push(ads16_9[i]);
                }
                
                // Add remaining ads from the longer list (orphaned by format)
                if (ads1_1.length > ads16_9.length) {
                  for (let i = minPairs; i < ads1_1.length; i++) {
                    final1_1.push(ads1_1[i]);
                  }
                } else if (ads16_9.length > ads1_1.length) {
                  for (let i = minPairs; i < ads16_9.length; i++) {
                    final16_9.push(ads16_9[i]);
                  }
                }
              }
              
              // Update the lists with paired ads
              ads1_1List.length = 0;
              ads1_1List.push(...final1_1);
              ads16_9List.length = 0;
              ads16_9List.push(...final16_9);
              
              console.log('[AD-REVIEW] Paired ads by workflowId:', {
                '1:1': final1_1.map(a => ({ id: a.id, workflowId: a.workflowId })),
                '9:16': final16_9.map(a => ({ id: a.id, workflowId: a.workflowId }))
              });
            }

            setAds1_1(ads1_1List);
            setAds16_9(ads16_9List);
          }
        } catch (error) {
          console.error('Error fetching ads:', error);
        } finally {
          setLoading(false);
        }
      };
      fetchAds();
    }
  }, [jobId]);

  const handleAddToLibrary = (adId: string) => {
    setSavedIds(prev => new Set(prev).add(adId));
    console.log('Added to library:', adId);
  };

  const handleDelete = (adId: string) => {
    setDeletedIds(prev => new Set(prev).add(adId));
    console.log('Deleted:', adId);
  };

  const handleSave = async (adId: string, imageUrl: string) => {
    setDownloadedIds(prev => new Set(prev).add(adId));
    try {
      // Fetch the image
      const response = await fetch(imageUrl);
      const blob = await response.blob();
      
      // Create a download link
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      
      // Extract filename from URL or use adId
      const filename = imageUrl.split('/').pop() || `ad-${adId}.png`;
      link.download = filename;
      
      // Trigger download
      document.body.appendChild(link);
      link.click();
      
      // Cleanup
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
      
      console.log('Saved ad:', adId);
    } catch (error) {
      console.error('Error saving ad:', error);
    }
  };

  const handleComplete = () => {
    setHasCompleted(true);
  };

  // Trigger API call when hasCompleted is true
  useEffect(() => {
    if (!hasCompleted || isTest || !jobId) return;

    const saveActions = async () => {
      try {
        setIsCompleting(true);

        // Update database with all actions
        const response = await fetch('/api/ad-actions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            jobId,
            savedIds: Array.from(savedIds),
            deletedIds: Array.from(deletedIds),
            downloadedIds: Array.from(downloadedIds),
          }),
        });

        if (!response.ok) {
          throw new Error('Failed to update ad actions');
        }

        console.log('Ad actions saved successfully');
        setIsFinished(true);
      } catch (error) {
        console.error('Error saving ad actions:', error);
        setIsFinished(true);
      } finally {
        setIsCompleting(false);
        setLoading(false);
      }
    };

    saveActions();
  }, [hasCompleted, isTest, jobId, savedIds, deletedIds, downloadedIds]);

  // Show completion message if finished
  if (isFinished) {
    return (
      <div className={styles.emptyState}>
        <h2>No more ads to review</h2>
        <p>All ads have been reviewed!</p>
      </div>
    );
  }

  if (loading || isCompleting) {
    return (
      <div className={styles.loadingContainer}>
        <div className={styles.spinner}></div>
        <p>{loading ? 'Loading ads...' : 'Saving your selections...'}</p>
      </div>
    );
  }

  // For mixed format, use separate component with connected ads
  if (format === 'mixed') {
    return (
      <TinderViewMixed
        ads1_1={ads1_1}
        ads16_9={ads16_9}
        onAddToLibrary={handleAddToLibrary}
        onDelete={handleDelete}
        onSave={handleSave}
        onComplete={handleComplete}
      />
    );
  }

  // For single format, use regular view
  const ads = format === '1:1' ? ads1_1 : ads16_9;
  
  return (
    <TinderView
      ads={ads}
      format={format}
      onAddToLibrary={handleAddToLibrary}
      onDelete={handleDelete}
      onSave={handleSave}
      onComplete={handleComplete}
    />
  );
}

export default function TinderPage() {
  return (
    <Suspense fallback={
      <div style={{ 
        display: 'flex', 
        alignItems: 'center', 
        justifyContent: 'center', 
        height: '100vh'
      }}>
        <p>Loading...</p>
      </div>
    }>
      <TinderPageContent />
    </Suspense>
  );
}

